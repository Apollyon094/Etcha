<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/2002/REC-xhtml1-20020801/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<title>The Etcha Programming Language</title>
  <!-- begin html doc dynamic markup -->
  <script type="text/javascript" src="/contrib/jquery-1.6.4.min.js"></script>
  <script type="text/javascript" src="/scripts/documentation.js"></script>
  <!-- end html doc dynamic markup -->
</head>
<body>

<h1>The Etcha Programming Language</h1>

<h2>Introduction</h2>

<p><dfn>Etcha</dfn> is an esoteric programming language based on Jeffry Johnston's <a class="external" href="http://www.esolangs.org/wiki/BitChanger">BitChanger</a>.
Like BitChanger, Etcha has four instructions, two of which are used to form Brainfuck-like while-loops.
Unlike BitChanger, Etcha has a 2-dimensional storage model based on <dfn>turtle graphics</dfn>, which permits it
to be immediately used for an alternative purpose: graphical composition.  Unlike a classical turtle in a language such
as LOGO however, the turtle in Etcha is an integral part of the computation, playing a role similar to the
tape head of a Turing machine.</p>

<h2>Instructions</h2>

<ul>
<li><code>+</code> -- equivalent to FD 1</li>
<li><code>&gt;</code> -- equivalent to RT 90; toggles PU/PD every 4 executions</li>
<li><code>[</code> -- equivalent to While</li>
<li><code>]</code> -- equivalent to Wend</li>
</ul>

<p>In Etcha, instructions control a <dfn>turtle</dfn>.  The turtle exists vis-a-vis
an unbounded Cartesian grid called the <dfn>playfield</dfn>.
The turtle has a <dfn>position</dfn> in that it occupies exactly one of the points on the playfield
(which are referred to as <dfn>pixels</dfn>).  Each pixel has a
<dfn>state</dfn>, which is either black or white; all pixels are initially black.</p>

<p>The turtle also has an
<dfn>orientation</dfn> which describes the direction it would move in should it travel forward.  Unlike a conventional
turtle, because of its Cartesian context, there are only four possible orientations which the Etcha turtle can possess: north, east, south,
and west, corresponding to headings of 0, 90, 180, and 270 degrees.
When an Etcha program starts, the turtle is initially oriented north.  Because position is relative, it doesn't matter where the turtle is initially located,
but solely for psychological satisfaction we can say that it is initially situated in the very center of this unbounded Cartesian grid.</p>

<p>The turtle is also equipped with a <dfn>pen</dfn>, which has a <dfn>pen mode</dfn> and a <dfn>pen position</dfn>.
The pen mode is always XOR, meaning that when moving forward by execution of <code>+</code>, the
state of the pixel that was previously occupied by the turtle gets inverted (from black to white, or vice versa.)  The pen position may be up or down.
It is initially down.  Every fourth time an <code>&gt;</code> instruction is executed, the pen's position is toggled from up to down
or vice versa.  These executions need not be consecutive; there may be any number of intervening instructions executed.</p>

<h2>Computational Class</h2>

<p>Etcha is Turing-complete if BitChanger is, because we can easily translate any BitChanger program into an equivalent Etcha
program.  Let the Etcha program begin with <code>&gt;&gt;&gt;&gt;</code>, to initially lift the pen.  The BitChanger
instruction <code>&lt;</code> is translated to the Etcha instructions <code>&gt;&gt;&gt;+&gt;&gt;&gt;&gt;&gt;</code>,
and the BitChanger instruction <code>}</code> is translated to <code>&gt;&gt;&gt;&gt;&gt;+&gt;&gt;&gt;</code>.
The instructions <code>[</code> and <code>]</code> remain the same.  The relation between the BitChanger tape state
and the Etcha playfield is quite literal; the <var>y</var> dimension of the grid is simply ignored.</p>

<h2>Implementation</h2>

<p>In a particular implementation of Etcha on a microcomputer with a finite storage, the playfield cannot be truly unbounded,
and there will come a point in a long enough program execution, entirely dependent on the capabilities of the hardware and the
implementation, where a pixel change cannot be correctly stored.  The behaviour after this point is undefined.  <i>Such
<b>m</b>icro<b>c</b>omputer implementations of Etcha may be marketed under the name "MC Etcha".</i></p>

<p>Cat's Eye Technologies provides an implementation of Etcha written in the Java<sup>TM</sup> programming language.
This implementation attempts to demonstrate that the Model-View-Controller design pattern can be applied
not only to user interfaces, but also to programming language interpreters.  The Model is the state of the
program (which is also the state of the Turtle graphics engine.)  The View is the interpreter's interpretation of that
state, and the Controller is the interpreter's behaviour with respect to the View.  For example, the Model exposes
the pen up/down semantics, but it is the Controller that implements the rule that <code>&gt;&gt;&gt;&gt;</code>
toggles the pen position.</p>

<p>Happy Etchin'!
<br/>Chris Pressey
<br/>October 4<sup>th</sup>, 2009
<br/>Mold City, USA</p>

</body>
</html>
